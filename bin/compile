#!/usr/bin/env bash

BUILDPACK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd .. && pwd)"

set -euo pipefail

BUILD_DIR="${1}"
CACHE_DIR="${2}"
ENV_DIR="${3}"

# shellcheck source=lib/output.sh
source "${BUILDPACK_DIR}/lib/output.sh"
# shellcheck source=lib/java_properties.sh
source "${BUILDPACK_DIR}/lib/java_properties.sh"
# shellcheck source=lib/config.sh
source "${BUILDPACK_DIR}/lib/config.sh"
# shellcheck source=lib/metrics.sh
source "${BUILDPACK_DIR}/lib/metrics.sh"
# shellcheck source=lib/util.sh
source "${BUILDPACK_DIR}/lib/util.sh"
# shellcheck source=lib/openjdk.sh
source "${BUILDPACK_DIR}/lib/openjdk.sh"
# shellcheck source=lib/sbt.sh
source "${BUILDPACK_DIR}/lib/sbt.sh"

metrics::init "${CACHE_DIR}" "scala"
metrics::setup

util::export_env_dir "${ENV_DIR}" "." "JAVA_OPTS"

# sbt Java system properties that configure directory locations, applied during both build and runtime
# Data structure: "sbt_property|cache_relative_path|slug_relative_path"
# Paths are relative to CACHE_DIR and BUILD_DIR/app root respectively
readonly sbt_directory_properties=(
	"sbt.ivy.home|ivy_home|.sbt_home/.ivy2"
	"sbt.coursier.home|coursier_home|.sbt_home/.coursier"
	"sbt.boot.directory|sbt_boot|.sbt_home/boot"
	"sbt.global.base|sbt_global|.sbt_home"
)

# Default sbt Java system properties set by the buildpack, applied during both build and runtime
readonly sbt_buildpack_default_properties=(
	"sbt.log.noformat=true"
	"sbt.color=false"
)

readonly sbt_launcher_dir_name="sbt-launcher"

# The buildpack's caching directories changed in November 2025. To ensure the cache created by older
# Scala buildpack versions doesn't stay around indefinitely, we explicitly delete these old directories.
# This will speed up subsequent app builds since it will take less time to restore the cache before each build.
rm -rf \
	"${CACHE_DIR}/.coursier" \
	"${CACHE_DIR}/.sbt_home" \
	"${CACHE_DIR}/project"

# Used by openjdk::install_openjdk_via_jvm_common_buildpack to determine which JVM common buildpack to use
# Configuring this via system.properties is deprecated and will be removed soon
# shellcheck disable=SC2034
JVM_COMMON_BUILDPACK="$(config::get "${BUILD_DIR}" "heroku.jvm.buildpack" "JVM_COMMON_BUILDPACK" "https://buildpack-registry.s3.us-east-1.amazonaws.com/buildpacks/heroku/jvm.tgz")"

SBT_PROJECT="$(config::get "${BUILD_DIR}" "sbt.project" "SBT_PROJECT")"
SBT_PRE_TASKS="$(config::get "${BUILD_DIR}" "sbt.pre-tasks" "SBT_PRE_TASKS")"
SBT_CLEAN="$(config::get "${BUILD_DIR}" "sbt.clean" "SBT_CLEAN" "false")"

# Track usage of configuration options
for env_var in SBT_PRE_TASKS SBT_PROJECT SBT_TASKS KEEP_SBT_CACHE SBT_CLEAN DISABLE_DEPENDENCY_CLASSPATH_LOG SBT_AT_RUNTIME; do
	if [[ -n "${!env_var:-}" ]]; then
		metrics::set_string "${env_var,,}" "${!env_var}"
	fi
done

# Install the JDK
openjdk::install_openjdk_via_jvm_common_buildpack "${BUILD_DIR}" "${BUILDPACK_DIR}"

sbt_version="$(java_properties::get "${BUILD_DIR}/project/build.properties" "sbt.version")"
metrics::set_string "sbt_version" "${sbt_version:-"unknown"}"

if [[ -z "${sbt_version}" ]]; then
	output::error <<-EOF
		Error: sbt version cannot be determined.

		As part of your build definition you must specify the version of sbt that
		your build uses. This ensures consistent results across different environments.

		To fix this issue, create a file named project/build.properties that specifies
		the sbt version as follows:

		    sbt.version=1.11.7

		For more information, see:
		https://www.scala-sbt.org/1.x/docs/Basic-Def.html#Specifying+the+sbt+version
	EOF

	exit 1
fi

case "${sbt_version}" in
0.*)
	output::warning <<-EOF
		Warning: Unsupported sbt version detected.

		This buildpack does not officially support sbt ${sbt_version}. You are using
		an end-of-life version that no longer receives security updates or bug fixes.
		Support for sbt 0.x was ended by the upstream sbt project on November 30, 2018.

		Please upgrade to sbt 1.x for active support.

		The buildpack will attempt to build your application, but compatibility
		is not guaranteed and may break at any time.

		For more information:
		- https://web.archive.org/web/20210918065807/https://www.lightbend.com/blog/scala-sbt-127-patchnotes

		Upgrade guide:
		- https://www.scala-sbt.org/1.x/docs/Migrating-from-sbt-013x.html
	EOF
	;;
2.*)
	output::error <<-EOF
		Error: Unsupported sbt version detected.

		This buildpack does not currently support sbt 2.x. You are using sbt ${sbt_version}.

		Support for sbt 2.x will be added in a future buildpack release. In the
		meantime, please use the latest stable sbt 1.x version for your deployments.

		To continue, update project/build.properties to use sbt 1.x.

		For more information:
		- Latest sbt 1.x releases: https://github.com/sbt/sbt/releases
		- sbt 2.x changes: https://www.scala-sbt.org/2.x/docs/en/changes/sbt-2.0-change-summary.html
	EOF

	exit 1
	;;
esac

# Copy the target dir from cache to speed up compilation. This is legacy buildpack
# behavior that other JVM buildpacks don't implement. It can cause cache bloat, stale artifacts,
# and reduced build reproducibility. We've observed customers using SBT_CLEAN (which will remove these files)
# much more than expected (~10% of builds), presumably to work around issues.
# This will be removed in a future version.
target_dir_cache_restore_start_time=$(util::nowms)
util::cache_copy "target" "${CACHE_DIR}" "${BUILD_DIR}"
metrics::set_duration "target_dir_cache_restore_duration" "${target_dir_cache_restore_start_time}"

SBT_TASKS="${SBT_TASKS:-compile stage}"

if [[ -n "${SBT_PRE_TASKS}" ]]; then
	output::warning <<-EOF
		Warning: SBT_PRE_TASKS is deprecated.

		The SBT_PRE_TASKS configuration option is deprecated and will be removed
		in a future buildpack version.

		Instead of using SBT_PRE_TASKS, add your tasks directly to SBT_TASKS:

		    heroku config:set SBT_TASKS="${SBT_PRE_TASKS} compile stage"

		The buildpack will continue to use your SBT_PRE_TASKS configuration for now.
	EOF

	SBT_TASKS="${SBT_PRE_TASKS} ${SBT_TASKS}"
fi

# Prepend 'clean' task when SBT_CLEAN is enabled to remove all generated files before compilation.
# See: https://devcenter.heroku.com/articles/scala-support#clean-builds
if [[ "${SBT_CLEAN}" = "true" ]]; then
	SBT_TASKS="clean ${SBT_TASKS}"
fi

# Apply project prefix to all tasks when SBT_PROJECT is set. This ensures the project prefix is
# applied both to the buildpack's default tasks (compile/stage) and any custom tasks set by users.
# See: https://www.scala-sbt.org/1.x/docs/Multi-Project.html
if [[ -n "${SBT_PROJECT}" ]]; then
	prefixed_sbt_tasks=""
	for sbt_task in ${SBT_TASKS}; do
		prefixed_sbt_tasks="${prefixed_sbt_tasks:+$prefixed_sbt_tasks }${SBT_PROJECT}/${sbt_task}"
	done

	SBT_TASKS="${prefixed_sbt_tasks}"
fi

for default_property in "${sbt_buildpack_default_properties[@]}"; do
	util::prepend_to_env "SBT_OPTS" "-D${default_property}"
done

# Create sbt directories and configure SBT_OPTS for build time
for directory_property in "${sbt_directory_properties[@]}"; do
	IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
	mkdir -p "${CACHE_DIR}/${cache_path}"
	util::prepend_to_env "SBT_OPTS" "-D${sbt_property}=${CACHE_DIR}/${cache_path}"
done

# Install the Heroku sbt plugin if the exising version differs (or is missing). We do this conditionally to
# ensure we can cache the compiled class files of the plugin between builds, speeding up the build overall.
case "${sbt_version}" in
0.*)
	plugin_source_path="${BUILDPACK_DIR}/opt/sbt-plugin/sbt-0.x/HerokuBuildpackPlugin.scala"
	;;
*)
	plugin_source_path="${BUILDPACK_DIR}/opt/sbt-plugin/sbt-1.x/HerokuBuildpackPlugin.scala"
	;;
esac

plugins_dir="${CACHE_DIR}/sbt_global/plugins"
plugin_destination_path="${plugins_dir}/HerokuBuildpackPlugin.scala"
source_checksum="$(sha256sum "${plugin_source_path}" | awk '{print $1}')"

if [[ ! -f "${plugin_destination_path}" ]] || [[ "${source_checksum}" != "$(sha256sum "${plugin_destination_path}" | awk '{print $1}')" ]]; then
	# We remove the whole directory since we also want to remove the (cached) compiled files
	# for the older version of the plugin in the ./target directory.
	rm -rf "${plugins_dir}"

	mkdir -p "${plugins_dir}"
	cp "${plugin_source_path}" "${plugin_destination_path}"
fi

sbt::install_sbt_launcher "${sbt_version}" "${CACHE_DIR}/sbt-launcher"
export PATH="${CACHE_DIR}/sbt-launcher/bin:${PATH}"

cd "${BUILD_DIR}"

output::step "Running: sbt ${SBT_TASKS}"
build_log_file="$(mktemp)"
# shellcheck disable=SC2086
if ! sbt ${SBT_TASKS} 2>&1 | tee -a "${build_log_file}" | output::indent; then
	sbt::output_build_error_message "${build_log_file}"
	exit 1
fi

# Gather information about relevant installed sbt plugins
sbt_about_start_time=$(util::nowms)
output::step "Collecting sbt plugin information"
sbt_about_output="$(sbt ${SBT_PROJECT:+$SBT_PROJECT/}about 2>&1)"
metrics::set_duration "sbt_about_duration" "${sbt_about_start_time}"

if echo "${sbt_about_output}" | grep --quiet --fixed-strings "com.typesafe.sbt.SbtNativePackager"; then
	app_has_native_packager_sbt_plugin="true"
	metrics::set_raw "uses_sbt_native_packager" "true"
fi

if echo "${sbt_about_output}" | grep --quiet --fixed-strings "play.sbt.Play"; then
	metrics::set_raw "is_play_app" "true"
fi

# Collect dependency classpath information for Postgres addon auto-provisioning. This creates a log file containing
# all dependencies and their paths, which is used by bin/release to detect if the app uses Postgres drivers. This
# can be disabled by setting DISABLE_DEPENDENCY_CLASSPATH_LOG if issues occur during dependency resolution.
if [[ -z "${DISABLE_DEPENDENCY_CLASSPATH_LOG:-}" ]]; then
	dependency_classpath_log_start_time=$(util::nowms)
	output::step "Collecting dependency information"
	# With some sbt + Java version combinations, Java reflective access warnings are written to stderr. Redirect stderr to avoid spilling these warnings to the build output.
	sbt "show ${SBT_PROJECT:+$SBT_PROJECT/}dependencyClasspath" 2>/dev/null | grep -o "Attributed\(.*\)" >.heroku/sbt-dependency-classpath.log || true
	metrics::set_duration "dependency_classpath_log_duration" "${dependency_classpath_log_start_time}"
fi

# Copy the target dir back to cache for the next build (see cache restore comment above for context)
target_dir_cache_write_start_time=$(util::nowms)
util::cache_copy "target" "${BUILD_DIR}" "${CACHE_DIR}"
metrics::set_duration "target_dir_cache_write_duration" "${target_dir_cache_write_start_time}"

# Write export script for use by subsequent buildpacks. The export script sets up the environment so that other
# buildpacks in the chain can access sbt and its configuration during their build phase. This script is sourced by
# the buildpack framework between buildpack executions.
cat <<-EOF >"${BUILDPACK_DIR}/export"
	export PATH="${CACHE_DIR}/${sbt_launcher_dir_name}/bin:\$PATH"

	$(for default_property in "${sbt_buildpack_default_properties[@]}"; do
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${default_property}\""
	done)

	$(for directory_property in "${sbt_directory_properties[@]}"; do
		IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${sbt_property}=${CACHE_DIR}/${cache_path}\""
	done)
EOF

# Historically, the buildpack made sbt and all cached dependencies available at runtime. While we eventually want to
# phase out this feature for parity with other JVM buildpacks, we still support it for backwards compatibility. To
# preserve this feature, we copy all sbt-related directories into the slug and write a profile.d script so that sbt
# will find those directories at runtime. This approach keeps the buildpack source clean and makes it easy to phase
# out this feature in the future.
if [[ "${SBT_AT_RUNTIME:-"true"}" == "true" ]]; then
	sbt_runtime_copy_start_time=$(util::nowms)
	output::step "Copying sbt and dependencies into slug for runtime use"

	# Copy sbt launcher from cache into slug
	if [[ -d "${CACHE_DIR}/${sbt_launcher_dir_name}" ]]; then
		mkdir -p "${BUILD_DIR}/.heroku/scala"
		cp -r "${CACHE_DIR}/${sbt_launcher_dir_name}" "${BUILD_DIR}/.heroku/scala/${sbt_launcher_dir_name}"
	fi

	profile_d_script_path="${BUILD_DIR}/.profile.d/scala.sh"
	mkdir -p "$(dirname "${profile_d_script_path}")"
	cat <<-EOF >"${profile_d_script_path}"
		export PATH="\$HOME/.heroku/scala/${sbt_launcher_dir_name}/bin:\$PATH"
	EOF

	for directory_property in "${sbt_directory_properties[@]}"; do
		IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
		mkdir -p "${BUILD_DIR}/${slug_path}"
		# For historic reasons, some sbt runtime directories are configured to be subdirectories of
		# each other. Using '/.' copies the contents of the source into the destination, preventing
		# 'cp' from creating an additional layer of directories when the destination already exists.
		cp -r "${CACHE_DIR}/${cache_path}/." "${BUILD_DIR}/${slug_path}/"
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${sbt_property}=\$HOME/${slug_path}\"" >>"${profile_d_script_path}"
	done

	for default_property in "${sbt_buildpack_default_properties[@]}"; do
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${default_property}\"" >>"${profile_d_script_path}"
	done

	metrics::set_duration "sbt_runtime_copy_duration" "${sbt_runtime_copy_start_time}"
fi

# When sbt-native-packager is used, a standalone JAR file with all code and dependencies is created. This makes the
# other JAR and class files redundant since they are not used by the running application. We remove these files here
# to reduce the slug size. However, this is a broad assumption that is often but not always correct. Users might want
# to use these files to run the application differently or for other purposes. This is legacy behavior that we will not
# change at this point to avoid users running into slug size limits needlessly. Ideally customers would curate their
# builds to not include extraneous files.
if [[ -n "${app_has_native_packager_sbt_plugin:-}" ]] && [[ "${KEEP_SBT_CACHE:-}" != "true" ]]; then
	artifact_cleanup_start_time=$(util::nowms)
	output::step "Dropping compilation artifacts from the slug"
	rm -rf "${BUILD_DIR}/target/scala-"*
	rm -rf "${BUILD_DIR}/target/streams"
	find "${BUILD_DIR}/target/resolution-cache" -mindepth 1 ! -name "reports" ! -name "*-compile.xml" -exec rm -rf {} + 2>/dev/null || true

	for directory_property in "${sbt_directory_properties[@]}"; do
		IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
		# sbt's global directory must not be deleted. It does not contain compilation artifacts related to
		# the customers app and is required for sbt operations at runtime.
		if [[ "${sbt_property}" == "sbt.global.base" ]]; then
			continue
		fi

		rm -rf "${BUILD_DIR:?}/${slug_path:?}"/*
	done

	metrics::set_duration "artifact_cleanup_duration" "${artifact_cleanup_start_time}"
fi
