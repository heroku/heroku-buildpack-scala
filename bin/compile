#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir>

# fail fast
set -e

BIN_DIR=$(cd $(dirname $0); pwd) # absolute path

# parse args
BUILD_DIR=$(cd $1; pwd)
CACHE_DIR=$2

# home directory from perspective of SBT; we rename
# it because otherwise the project root and $HOME
# are the same, and by default .sbt has a (different)
# meaning in those two places
SBT_USER_HOME=".sbt_home"
SBT_USER_HOME_ABSOLUTE="$BUILD_DIR/$SBT_USER_HOME"
# where we put the SBT binaries
SBT_BINDIR="$SBT_USER_HOME"/bin

# chdir as sbt expects
cd $BUILD_DIR

# unpack cache
CACHED_DIRS="$SBT_USER_HOME/.ivy2 $SBT_BINDIR"
for DIR in $CACHED_DIRS; do
  rm -rf $DIR
  if [ -d $CACHE_DIR/$DIR ]; then
    mkdir -p $DIR
    cp -r --no-target-directory $CACHE_DIR/$DIR $DIR
  fi
done

## Determine SBT version. Only 0.7 and 0.10
## are currently supported. Easiest to check for 0.7
## since it requires build.properties to exist.
if test -e project/build.properties && \
   ! grep -q 'sbt.version *= *0\.10' project/build.properties ; then
    echo "-----> Selecting SBT 0.7.7"
    SBT_VERSION="0.7.7"
    SBT_JAR="sbt-launch-$SBT_VERSION.jar"
    SBT_URL="http://s3.amazonaws.com/sclasen-langpack-scala/$SBT_JAR"
    SBT_SHA1="6b5ba879e80a0464c9eaae786bef494e448e6df7"
    SBT_TASKS="clean clean-lib update package"
else
    echo "-----> Selecting SBT 0.10"
    SBT_VERSION="0.10.1"
    SBT_JAR="sbt-launch-$SBT_VERSION.jar"
    SBT_URL="http://s3.amazonaws.com/sclasen-langpack-scala/$SBT_JAR"
    SBT_SHA1="b41d79cb2d919a0e8732fb8ef4e71347cceea90a"
    ## in 0.10 start-script will depend on package, if packaging
    ## is required - it may not be, we can run .class files or a package-war
    ## instead.
    SBT_TASKS="clean compile"
fi

if [ ! -d .ivy2/cache ]; then
   mkdir -p .ivy2/cache
fi

if [ ! -f "$SBT_BINDIR"/"$SBT_JAR" ]; then
  mkdir -p "$SBT_BINDIR"
  cd "$SBT_BINDIR"

  ## clean up any old versions
  /bin/rm -f sbt sbt-launch-*.jar || true

  echo -n "-----> Installing SBT from $SBT_URL..."
  curl --silent --max-time 60 -O --location $SBT_URL

  ## some of the downloads don't have the version in the name,
  ## fix it.
  if [ -f "sbt-launch.jar" ] ; then
      mv "sbt-launch.jar" "$SBT_JAR"
  fi

  ## verify SHA1
  FOUND_SHA1=`sha1sum $SBT_JAR | cut -d ' ' -f 1`
  if test "$SBT_SHA1" != "$FOUND_SHA1" ; then
      echo " failed"
      echo " !     Expected SHA1 \"$SBT_SHA1\" but found \"$FOUND_SHA1\" for $SBT_JAR from $SBT_URL"
      exit 1
  fi

  cd $BUILD_DIR
  echo " done"
fi

#copy the sbt script (do this every time so we can change it if necessary,
#for example if switching sbt version, or just updates to the script)
cp "$BIN_DIR/../opt/sbt-$SBT_VERSION" "$SBT_BINDIR"/sbt

test -e "$BIN_DIR/../opt/sbt-$SBT_VERSION.boot.properties" && cp $BIN_DIR/../opt/sbt-$SBT_VERSION.boot.properties "$SBT_BINDIR"/sbt.boot.properties

HEROKU_PLUGIN="Heroku-$SBT_VERSION.scala"
test -e "$BIN_DIR/../opt/$HEROKU_PLUGIN" && mkdir -p "$SBT_USER_HOME/.sbt/plugins/project" && cp "$BIN_DIR/../opt/$HEROKU_PLUGIN" "$SBT_USER_HOME/.sbt/plugins/project/$HEROKU_PLUGIN"

HEROKU_PLUGINS_CONFIG="heroku-plugins-$SBT_VERSION.sbt"
test -e "$BIN_DIR/../opt/$HEROKU_PLUGINS_CONFIG" && mkdir -p "$SBT_USER_HOME/.sbt/plugins" && cp "$BIN_DIR/../opt/$HEROKU_PLUGINS_CONFIG" "$SBT_USER_HOME/.sbt/plugins/$HEROKU_PLUGINS_CONFIG"

START_SCRIPT_PLUGIN="StartScriptPlugin-$SBT_VERSION.scala"
#test -e "$BIN_DIR/../opt/$START_SCRIPT_PLUGIN" && mkdir -p "$SBT_USER_HOME/.sbt/plugins" && cp "$BIN_DIR/../opt/$START_SCRIPT_PLUGIN" "$SBT_USER_HOME/.sbt/plugins/$START_SCRIPT_PLUGIN"

# build app
echo "-----> Building app with SBT"
echo "-----> executing sbt $SBT_TASKS"
test -e "$SBT_BINDIR"/sbt.boot.properties && PROPS_OPTION="-Dsbt.boot.properties=$SBT_BINDIR/sbt.boot.properties"
HOME="$SBT_USER_HOME_ABSOLUTE" java -Xmx512M -Duser.home="$SBT_USER_HOME_ABSOLUTE" -Divy.default.ivy.user.dir="$SBT_USER_HOME_ABSOLUTE/.ivy2" $PROPS_OPTION -jar "$SBT_BINDIR"/$SBT_JAR $SBT_TASKS 2>&1 | sed -u 's/^/       /'
if [ "${PIPESTATUS[*]}" != "0 0" ]; then
  echo " !     Failed to build app with SBT $SBT_VERSION"
  exit 1
fi

# repack cache
mkdir -p $CACHE_DIR
for DIR in $CACHED_DIRS ; do
  rm -rf $CACHE_DIR/$DIR
  mkdir -p $CACHE_DIR/$DIR
  cp -r --no-target-directory $DIR $CACHE_DIR/$DIR
done
