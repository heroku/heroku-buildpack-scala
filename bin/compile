#!/usr/bin/env bash
# bin/compile <build-dir> <cache-dir> <env-dir>

# fail fast
set -e

BASE_DIR="$(pwd)"
BP_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd .. && pwd)" # absolute path
# shellcheck source=lib/output.sh
source "${BP_DIR}/lib/output.sh"
# shellcheck source=lib/common.sh
source "${BP_DIR}/lib/common.sh"
# shellcheck source=lib/properties.sh
source "${BP_DIR}/lib/properties.sh"
# shellcheck source=lib/failures.sh
source "${BP_DIR}/lib/failures.sh"
# shellcheck source=lib/metrics.sh
source "${BP_DIR}/lib/metrics.sh"
# shellcheck source=lib/util.sh
source "${BP_DIR}/lib/util.sh"

# parse args
APP_BUILD_DIR=$(
	cd "${1}"
	pwd
)
CACHE_DIR="${2}"
ENV_DIR="${3}"

metrics::init "${CACHE_DIR}" "scala"
metrics::setup

if [[ -z "${CNB_STACK_ID:-}" ]]; then
	# Move app to a static build dir to keep paths the same between builds
	# This is necessary for incremental compile, because sbt invalidates the
	# cache if the path is different.
	if is_app_dir "${APP_BUILD_DIR}"; then
		BUILD_DIR="/tmp/scala_buildpack_build_dir"
		mv "${APP_BUILD_DIR}" "${BUILD_DIR}"
	else
		BUILD_DIR="${APP_BUILD_DIR}"
	fi

	# When multiple buildpacks are used, earlier buildpacks may add executables to PATH
	# and GEM_PATH that reference APP_BUILD_DIR. Since we've moved the build directory to
	# a temp location, we must rewrite these environment variables to replace APP_BUILD_DIR
	# with the new BUILD_DIR so that executables added by earlier buildpacks remain accessible.
	PATH=${PATH//"${APP_BUILD_DIR}"/"${BUILD_DIR}"}
	export PATH
	GEM_PATH=${GEM_PATH//"${APP_BUILD_DIR}"/"${BUILD_DIR}"}
	export GEM_PATH
else
	BUILD_DIR="${APP_BUILD_DIR}"
fi

util::export_env_dir "${ENV_DIR}" "." "JAVA_OPTS"

# Set system properties as env vars
SYSPROPFILE="${BUILD_DIR}/system.properties"

JVM_COMMON_BUILDPACK="${JVM_COMMON_BUILDPACK:-https://buildpack-registry.s3.us-east-1.amazonaws.com/buildpacks/heroku/jvm.tgz}"
JVM_COMMON_BUILDPACK="$(get_property "${SYSPROPFILE}" "heroku.jvm.buildpack" "${JVM_COMMON_BUILDPACK}")"
KEEP_PLAY_FORK_RUN="$(get_property "${SYSPROPFILE}" "sbt.keep-play-fork-run" "${KEEP_PLAY_FORK_RUN:-false}")"
SBT_PROJECT="$(get_property "${SYSPROPFILE}" "sbt.project")"
SBT_PRE_TASKS="$(get_property "${SYSPROPFILE}" "sbt.pre-tasks" "${SBT_PRE_TASKS}")"
SBT_CLEAN="$(get_property "${SYSPROPFILE}" "sbt.clean" "${SBT_CLEAN:-false}")"

[[ -n "${SBT_PRE_TASKS}" ]] && metrics::set_string "sbt_pre_tasks" "${SBT_PRE_TASKS}"
[[ -n "${SBT_PROJECT}" ]] && metrics::set_string "sbt_project" "${SBT_PROJECT}"
[[ -n "${SBT_TASKS:-}" ]] && metrics::set_string "sbt_tasks" "${SBT_TASKS}"
[[ -n "${KEEP_PLAY_FORK_RUN}" ]] && metrics::set_string "keep_play_fork_run" "${KEEP_PLAY_FORK_RUN}"
[[ -n "${KEEP_SBT_CACHE}" ]] && metrics::set_string "keep_sbt_cache" "${KEEP_SBT_CACHE}"
[[ -n "${KEEP_COURSIER_CACHE}" ]] && metrics::set_string "keep_coursier_cache" "${KEEP_COURSIER_CACHE}"
[[ -n "${SBT_CLEAN}" ]] && metrics::set_string "sbt_clean" "${SBT_CLEAN}"
[[ -n "${DISABLE_DEPENDENCY_CLASSPATH_LOG:-}" ]] && metrics::set_string "disable_dependency_classpath_log" "${DISABLE_DEPENDENCY_CLASSPATH_LOG}"

# Install the JDK
install_jdk "${BUILD_DIR}" "${CACHE_DIR}"

#create the cache dir if it doesn't exist
mkdir -p "${CACHE_DIR}"

# home directory from perspective of SBT; we rename
# it because otherwise the project root and $HOME
# are the same, and by default .sbt has a (different)
# meaning in those two places
SBT_USER_HOME=".sbt_home"
SBT_USER_HOME_ABSOLUTE="${BUILD_DIR}/${SBT_USER_HOME}"
# where we put the SBT binaries
SBT_BINDIR="${SBT_USER_HOME}/bin"

# chdir as sbt expects
cd "${BUILD_DIR}"

# unpack cache
CACHED_DIRS="${SBT_USER_HOME} target project/target project/boot .coursier"
for DIR in ${CACHED_DIRS}; do
	cache_copy "${DIR}" "${CACHE_DIR}" "${BUILD_DIR}"
done

# these are preliminary checks. actual version check happens below when attempting to download sbt boot.properties
if ! test -e project/build.properties; then
	output::error <<-EOF
		Your scala project must include project/build.properties and define sbt.version
	EOF
fi

if ! (has_supported_sbt_version "${BUILD_DIR}" || has_supported_sbt_1_version "${BUILD_DIR}"); then
	output::error <<-EOF
		You have defined an unsupported sbt.version in project/build.properties
		For sbt 0.x you must use a version >= 0.11, for sbt 1.x you must use a version >= 1.1
	EOF
fi

if has_old_preset_sbt_opts; then
	output::warning <<-EOF
		Your SBT_OPTS config var looks like its not in the right form.
		It was probably set this way in an earlier version of the buildpack. The
		only ill effect should be a warning like \"The \`-\` command is deprecated\".
		To avoid any unexpected behavior, please unset it by running this command:

			$ heroku config:unset SBT_OPTS

		The buildpack will pick good defaults for you, but you can still customize
		sbt's execution as described in this article:
		https://github.com/paulp/sbt-extras#sample-usage
	EOF
fi

if [[ "${KEEP_PLAY_FORK_RUN}" != "true" ]] && [[ -f project/play-fork-run.sbt ]]; then
	output::warning <<-EOF
		Removing project/play-fork-run.sbt. This file was probably added
		by Activator, and it breaks sbt. For more information see:
		https://github.com/typesafehub/activator/issues/979

		If you need to keep this file you can either rename it or set the following
		configuration variable:
		$ heroku config:set KEEP_PLAY_FORK_RUN=true
	EOF

	rm project/play-fork-run.sbt
fi

SBT_VERSION="$(get_supported_sbt_version "${BUILD_DIR}")"

if [[ -n "${SBT_PROJECT}" ]]; then
	SBT_TASKS="${SBT_PROJECT}/compile ${SBT_PROJECT}/stage"
else
	SBT_TASKS="${SBT_TASKS:-compile stage}"
fi

# To run any tasks before the actual build, configure the environment
# $ heroku config:set SBT_PRE_TASKS=flyway:info
[[ "${SBT_PRE_TASKS}" ]] && SBT_TASKS="${SBT_PRE_TASKS} ${SBT_TASKS}"

# To enable clean compiles, configure the environment to clean:
# $ heroku config:set SBT_CLEAN=true
# $ git push heroku main
# See: https://devcenter.heroku.com/articles/scala-support#clean-builds
[[ "${SBT_CLEAN}" = "true" ]] && SBT_TASKS="clean ${SBT_TASKS}"

# Install the custom sbt script
install_sbt_extras "${BP_DIR}/opt" "${SBT_BINDIR}"

# copy in heroku sbt plugin
if has_supported_sbt_1_version "${BUILD_DIR}"; then
	HEROKU_PLUGIN="HerokuBuildpackPlugin_sbt1.scala"
else
	HEROKU_PLUGIN="HerokuBuildpackPlugin.scala"
fi
mkdir -p "${SBT_USER_HOME}/plugins"
rm -f "${SBT_USER_HOME}/plugins/HerokuPlugin.scala"               # remove the old ambiguously named plugin
rm -f "${SBT_USER_HOME}/plugins/HerokuBuildpackPlugin_sbt1.scala" # remove the old poorly named plugin
rm -f "${SBT_USER_HOME}/plugins/HerokuBuildpackPlugin.scala"      # remove the old plugin
cp -p "${BP_DIR}/opt/${HEROKU_PLUGIN}" "${SBT_USER_HOME}/plugins/HerokuBuildpackPlugin.scala"

# Collect metrics
metrics::set_string "sbt_version" "${SBT_VERSION:-unknown}"

if is_sbt_native_packager "${BUILD_DIR}"; then
	metrics::set_raw "uses_sbt_native_packager" "true"
else
	metrics::set_raw "uses_sbt_native_packager" "false"
fi

if is_play "${BUILD_DIR}"; then
	metrics::set_raw "is_play_app" "true"
else
	metrics::set_raw "is_play_app" "false"
fi

# Manually pre-clean because sbt-native-packager doesn't clobber this dir
rm -rf "${BUILD_DIR}/target/universal/stage"

# download and cache the dependencies if this is the first build
if [[ ! -d "${SBT_USER_HOME}/.ivy2" ]]; then
	if is_sbt_native_packager "${BUILD_DIR}" || is_play "${BUILD_DIR}"; then
		prime_ivy_cache "${BUILD_DIR}" "${SBT_USER_HOME_ABSOLUTE}" "${SBT_BINDIR}/${SBT_JAR}"
	fi
fi

# build app
javaVersion="${JAVA_VERSION:-8}"
run_sbt "${javaVersion}" "${SBT_USER_HOME_ABSOLUTE}" "${SBT_BINDIR}/${SBT_JAR}" "${SBT_TASKS}"

if [[ -z "${DISABLE_DEPENDENCY_CLASSPATH_LOG:-}" ]]; then
	write_sbt_dependency_classpath_log "${SBT_USER_HOME_ABSOLUTE}" "${SBT_BINDIR}/${SBT_JAR}" "show dependencyClasspath"
fi

# repack cache
mkdir -p "${CACHE_DIR}"
for DIR in ${CACHED_DIRS}; do
	cache_copy "${DIR}" "${BUILD_DIR}" "${CACHE_DIR}"
done

# drop useless directories from slug for play and sbt-native-launcher only
if is_sbt_native_packager "${BUILD_DIR}" || is_play "${BUILD_DIR}"; then
	if [[ "${KEEP_SBT_CACHE}" != "true" ]]; then
		if [[ "${KEEP_IVY_CACHE}" != "true" ]] && [[ -d "${SBT_USER_HOME}/.ivy2" ]]; then
			output::step "Dropping ivy cache from the slug"
			rm -rf "${SBT_USER_HOME:?}/.ivy2"
		fi
		if [[ "${KEEP_COURSIER_CACHE}" != "true" ]] && [[ -d "${SBT_USER_HOME}/.coursier" ]]; then
			output::step "Dropping coursier cache from the slug"
			rm -rf "${SBT_USER_HOME:?}/.coursier"
		fi
		if [[ -d "${SBT_USER_HOME}/boot" ]]; then
			output::step "Dropping sbt boot dir from the slug"
			rm -rf "${SBT_USER_HOME:?}/boot"
		fi
		if [[ -d "${SBT_USER_HOME}/.cache" ]]; then
			output::step "Dropping sbt cache dir from the slug"
			rm -rf "${SBT_USER_HOME:?}/.cache"
		fi
		if [[ -d "${BUILD_DIR}/project/boot" ]]; then
			output::step "Dropping project boot dir from the slug"
			rm -rf "${BUILD_DIR}/project/boot"
		fi
		if [[ -d "${BUILD_DIR}/target" ]]; then
			output::step "Dropping compilation artifacts from the slug"
			rm -rf "${BUILD_DIR}/target/scala-"*
			rm -rf "${BUILD_DIR}/target/streams"
			if [[ -d "${BUILD_DIR}/target/resolution-cache" ]]; then
				find "${BUILD_DIR}/target/resolution-cache"/* ! -name "reports" ! -name "*-compile.xml" -print0 | xargs -0 rm -rf --
			fi
		fi
	fi
fi

# write profile.d script
profileScript="${BUILD_DIR}/.profile.d/scala.sh"
mkdir -p "$(dirname "${profileScript}")"
cat <<EOF >"${profileScript}"
export SBT_HOME="\$HOME/${SBT_USER_HOME}"
export PATH="\$SBT_HOME/bin:\$PATH"
EOF

# Move compiled app back to where Heroku expects it
if [[ -z "${CNB_STACK_ID:-}" ]] && is_app_dir "${APP_BUILD_DIR}"; then
	mv "${BUILD_DIR}" "${APP_BUILD_DIR}"
fi

# write export script
cat <<EOF >"${BASE_DIR}/export"
export SBT_HOME="${APP_BUILD_DIR}/${SBT_USER_HOME}"
export PATH="\$SBT_HOME/bin:\$PATH"
EOF
