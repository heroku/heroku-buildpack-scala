#!/usr/bin/env bash

BUILDPACK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd .. && pwd)"

set -euo pipefail

BUILD_DIR="${1}"
CACHE_DIR="${2}"
ENV_DIR="${3}"

BASE_DIR="$(pwd)"

# shellcheck source=lib/output.sh
source "${BUILDPACK_DIR}/lib/output.sh"
# shellcheck source=lib/common.sh
source "${BUILDPACK_DIR}/lib/common.sh"
# shellcheck source=lib/java_properties.sh
source "${BUILDPACK_DIR}/lib/java_properties.sh"
# shellcheck source=lib/config.sh
source "${BUILDPACK_DIR}/lib/config.sh"
# shellcheck source=lib/failures.sh
source "${BUILDPACK_DIR}/lib/failures.sh"
# shellcheck source=lib/metrics.sh
source "${BUILDPACK_DIR}/lib/metrics.sh"
# shellcheck source=lib/util.sh
source "${BUILDPACK_DIR}/lib/util.sh"

APP_BUILD_DIR=$(cd "${BUILD_DIR}" && pwd)

metrics::init "${CACHE_DIR}" "scala"
metrics::setup

if is_app_dir "${APP_BUILD_DIR}"; then
	BUILD_DIR="/tmp/scala_buildpack_build_dir"
	mv "${APP_BUILD_DIR}" "${BUILD_DIR}"
else
	BUILD_DIR="${APP_BUILD_DIR}"
fi

# When multiple buildpacks are used, earlier buildpacks may add executables to PATH
# and GEM_PATH that reference APP_BUILD_DIR. Since we've moved the build directory to
# a temp location, we must rewrite these environment variables to replace APP_BUILD_DIR
# with the new BUILD_DIR so that executables added by earlier buildpacks remain accessible.
PATH=${PATH//"${APP_BUILD_DIR}"/"${BUILD_DIR}"}
export PATH
if [[ -n "${GEM_PATH:-}" ]]; then
	GEM_PATH=${GEM_PATH//"${APP_BUILD_DIR}"/"${BUILD_DIR}"}
	export GEM_PATH
fi

util::export_env_dir "${ENV_DIR}" "." "JAVA_OPTS"

# Used by install_jdk to determine which JVM common buildpack to use
# Configuring this via system.properties is deprecated and will be removed soon
# shellcheck disable=SC2034
JVM_COMMON_BUILDPACK="$(config::get "${BUILD_DIR}" "heroku.jvm.buildpack" "JVM_COMMON_BUILDPACK" "https://buildpack-registry.s3.us-east-1.amazonaws.com/buildpacks/heroku/jvm.tgz")"

SBT_PROJECT="$(config::get "${BUILD_DIR}" "sbt.project" "SBT_PROJECT")"
SBT_PRE_TASKS="$(config::get "${BUILD_DIR}" "sbt.pre-tasks" "SBT_PRE_TASKS")"
SBT_CLEAN="$(config::get "${BUILD_DIR}" "sbt.clean" "SBT_CLEAN" "false")"

# Track usage of configuration options
for env_var in SBT_PRE_TASKS SBT_PROJECT SBT_TASKS KEEP_SBT_CACHE KEEP_COURSIER_CACHE SBT_CLEAN DISABLE_DEPENDENCY_CLASSPATH_LOG; do
	if [[ -n "${!env_var:-}" ]]; then
		metrics::set_string "${env_var,,}" "${!env_var}"
	fi
done

# Install the JDK
install_jdk "${BUILD_DIR}" "${CACHE_DIR}"

#create the cache dir if it doesn't exist
mkdir -p "${CACHE_DIR}"

# home directory from perspective of SBT; we rename
# it because otherwise the project root and $HOME
# are the same, and by default .sbt has a (different)
# meaning in those two places
SBT_USER_HOME=".sbt_home"
SBT_USER_HOME_ABSOLUTE="${BUILD_DIR}/${SBT_USER_HOME}"
# where we put the SBT binaries
SBT_BINDIR="${SBT_USER_HOME}/bin"

# chdir as sbt expects
cd "${BUILD_DIR}"

# unpack cache
CACHED_DIRS="${SBT_USER_HOME} target project/target project/boot .coursier"
for DIR in ${CACHED_DIRS}; do
	cache_copy "${DIR}" "${CACHE_DIR}" "${BUILD_DIR}"
done

sbt_version="$(java_properties::get "${BUILD_DIR}/project/build.properties" "sbt.version")"
metrics::set_string "sbt_version" "${sbt_version:-"unknown"}"

if [[ -z "${sbt_version}" ]]; then
	output::error <<-EOF
		Error: sbt version cannot be determined.

		As part of your build definition you must specify the version of sbt that
		your build uses. This ensures consistent results across different environments.

		To fix this issue, create a file named project/build.properties that specifies
		the sbt version as follows:

		    sbt.version=1.11.7

		For more information, see:
		https://www.scala-sbt.org/1.x/docs/Basic-Def.html#Specifying+the+sbt+version
	EOF

	exit 1
fi

case "${sbt_version}" in
0.*)
	output::warning <<-EOF
		Warning: Unsupported sbt version detected.

		This buildpack does not officially support sbt ${sbt_version}. You are using
		an end-of-life version that no longer receives security updates or bug fixes.
		Support for sbt 0.x was ended by the upstream sbt project on November 30, 2018.

		Please upgrade to sbt 1.x for active support.

		The buildpack will attempt to build your application, but compatibility
		is not guaranteed and may break at any time.

		For more information:
		- https://web.archive.org/web/20210918065807/https://www.lightbend.com/blog/scala-sbt-127-patchnotes

		Upgrade guide:
		- https://www.scala-sbt.org/1.x/docs/Migrating-from-sbt-013x.html
	EOF
	;;
2.*)
	output::error <<-EOF
		Error: Unsupported sbt version detected.

		This buildpack does not currently support sbt 2.x. You are using sbt ${sbt_version}.

		Support for sbt 2.x will be added in a future buildpack release. In the
		meantime, please use the latest stable sbt 1.x version for your deployments.

		To continue, update project/build.properties to use sbt 1.x.

		For more information:
		- Latest sbt 1.x releases: https://github.com/sbt/sbt/releases
		- sbt 2.x changes: https://www.scala-sbt.org/2.x/docs/en/changes/sbt-2.0-change-summary.html
	EOF

	exit 1
	;;
esac

if has_old_preset_sbt_opts; then
	output::warning <<-EOF
		Your SBT_OPTS config var looks like its not in the right form.
		It was probably set this way in an earlier version of the buildpack. The
		only ill effect should be a warning like \"The \`-\` command is deprecated\".
		To avoid any unexpected behavior, please unset it by running this command:

			$ heroku config:unset SBT_OPTS

		The buildpack will pick good defaults for you, but you can still customize
		sbt's execution as described in this article:
		https://github.com/paulp/sbt-extras#sample-usage
	EOF
fi

if [[ -n "${SBT_PROJECT}" ]]; then
	SBT_TASKS="${SBT_PROJECT}/compile ${SBT_PROJECT}/stage"
else
	SBT_TASKS="${SBT_TASKS:-compile stage}"
fi

# To run any tasks before the actual build, configure the environment
# $ heroku config:set SBT_PRE_TASKS=flyway:info
[[ "${SBT_PRE_TASKS}" ]] && SBT_TASKS="${SBT_PRE_TASKS} ${SBT_TASKS}"

# To enable clean compiles, configure the environment to clean:
# $ heroku config:set SBT_CLEAN=true
# $ git push heroku main
# See: https://devcenter.heroku.com/articles/scala-support#clean-builds
[[ "${SBT_CLEAN}" = "true" ]] && SBT_TASKS="clean ${SBT_TASKS}"

# Install the custom sbt script
install_sbt_extras "${BUILDPACK_DIR}/opt" "${SBT_BINDIR}"

# copy in heroku sbt plugin
case "${sbt_version}" in
1.*)
	HEROKU_PLUGIN="HerokuBuildpackPlugin_sbt1.scala"
	;;
*)
	HEROKU_PLUGIN="HerokuBuildpackPlugin.scala"
	;;
esac

mkdir -p "${SBT_USER_HOME}/plugins"
rm -f "${SBT_USER_HOME}/plugins/HerokuPlugin.scala"               # remove the old ambiguously named plugin
rm -f "${SBT_USER_HOME}/plugins/HerokuBuildpackPlugin_sbt1.scala" # remove the old poorly named plugin
rm -f "${SBT_USER_HOME}/plugins/HerokuBuildpackPlugin.scala"      # remove the old plugin
cp -p "${BUILDPACK_DIR}/opt/${HEROKU_PLUGIN}" "${SBT_USER_HOME}/plugins/HerokuBuildpackPlugin.scala"

# Collect metrics

if is_sbt_native_packager "${BUILD_DIR}"; then
	metrics::set_raw "uses_sbt_native_packager" "true"
else
	metrics::set_raw "uses_sbt_native_packager" "false"
fi

if is_play "${BUILD_DIR}"; then
	metrics::set_raw "is_play_app" "true"
else
	metrics::set_raw "is_play_app" "false"
fi

# Manually pre-clean because sbt-native-packager doesn't clobber this dir
rm -rf "${BUILD_DIR}/target/universal/stage"

# build app
run_sbt "${SBT_USER_HOME_ABSOLUTE}" "${SBT_TASKS}"

if [[ -z "${DISABLE_DEPENDENCY_CLASSPATH_LOG:-}" ]]; then
	write_sbt_dependency_classpath_log "${SBT_USER_HOME_ABSOLUTE}"
fi

# repack cache
mkdir -p "${CACHE_DIR}"
for DIR in ${CACHED_DIRS}; do
	cache_copy "${DIR}" "${BUILD_DIR}" "${CACHE_DIR}"
done

# drop useless directories from slug for play and sbt-native-launcher only
if is_sbt_native_packager "${BUILD_DIR}" || is_play "${BUILD_DIR}"; then
	if [[ "${KEEP_SBT_CACHE:-}" != "true" ]]; then
		if [[ "${KEEP_IVY_CACHE:-}" != "true" ]] && [[ -d "${SBT_USER_HOME}/.ivy2" ]]; then
			output::step "Dropping ivy cache from the slug"
			rm -rf "${SBT_USER_HOME:?}/.ivy2"
		fi
		if [[ "${KEEP_COURSIER_CACHE:-}" != "true" ]] && [[ -d "${SBT_USER_HOME}/.coursier" ]]; then
			output::step "Dropping coursier cache from the slug"
			rm -rf "${SBT_USER_HOME:?}/.coursier"
		fi
		if [[ -d "${SBT_USER_HOME}/boot" ]]; then
			output::step "Dropping sbt boot dir from the slug"
			rm -rf "${SBT_USER_HOME:?}/boot"
		fi
		if [[ -d "${SBT_USER_HOME}/.cache" ]]; then
			output::step "Dropping sbt cache dir from the slug"
			rm -rf "${SBT_USER_HOME:?}/.cache"
		fi
		if [[ -d "${BUILD_DIR}/project/boot" ]]; then
			output::step "Dropping project boot dir from the slug"
			rm -rf "${BUILD_DIR}/project/boot"
		fi
		if [[ -d "${BUILD_DIR}/target" ]]; then
			output::step "Dropping compilation artifacts from the slug"
			rm -rf "${BUILD_DIR}/target/scala-"*
			rm -rf "${BUILD_DIR}/target/streams"
			if [[ -d "${BUILD_DIR}/target/resolution-cache" ]]; then
				find "${BUILD_DIR}/target/resolution-cache"/* ! -name "reports" ! -name "*-compile.xml" -print0 | xargs -0 rm -rf --
			fi
		fi
	fi
fi

# write profile.d script
profile_script="${BUILD_DIR}/.profile.d/scala.sh"
mkdir -p "$(dirname "${profile_script}")"
cat <<-EOF >"${profile_script}"
	export SBT_HOME="\$HOME/${SBT_USER_HOME}"
	export PATH="\$SBT_HOME/bin:\$PATH"
EOF

# Move compiled app back to where Heroku expects it
if is_app_dir "${APP_BUILD_DIR}"; then
	mv "${BUILD_DIR}" "${APP_BUILD_DIR}"
fi

# write export script
cat <<-EOF >"${BASE_DIR}/export"
	export SBT_HOME="${APP_BUILD_DIR}/${SBT_USER_HOME}"
	export PATH="\$SBT_HOME/bin:\$PATH"
EOF
