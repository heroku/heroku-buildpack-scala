#!/usr/bin/env bash

BUILDPACK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && cd .. && pwd)"

set -euo pipefail

BUILD_DIR="${1}"
CACHE_DIR="${2}"
ENV_DIR="${3}"

BASE_DIR="$(pwd)"

# shellcheck source=lib/output.sh
source "${BUILDPACK_DIR}/lib/output.sh"
# shellcheck source=lib/common.sh
source "${BUILDPACK_DIR}/lib/common.sh"
# shellcheck source=lib/java_properties.sh
source "${BUILDPACK_DIR}/lib/java_properties.sh"
# shellcheck source=lib/config.sh
source "${BUILDPACK_DIR}/lib/config.sh"
# shellcheck source=lib/failures.sh
source "${BUILDPACK_DIR}/lib/failures.sh"
# shellcheck source=lib/metrics.sh
source "${BUILDPACK_DIR}/lib/metrics.sh"
# shellcheck source=lib/util.sh
source "${BUILDPACK_DIR}/lib/util.sh"
# shellcheck source=lib/openjdk.sh
source "${BUILDPACK_DIR}/lib/openjdk.sh"
# shellcheck source=lib/sbt.sh
source "${BUILDPACK_DIR}/lib/sbt.sh"

metrics::init "${CACHE_DIR}" "scala"
metrics::setup

util::export_env_dir "${ENV_DIR}" "." "JAVA_OPTS"

# sbt Java system properties that configure directory locations, applied during both build and runtime
# Data structure: "sbt_property|cache_relative_path|slug_relative_path"
# Paths are relative to CACHE_DIR and BUILD_DIR/app root respectively
readonly sbt_directory_properties=(
	"sbt.ivy.home|ivy_home|.sbt_home/.ivy2"
	"sbt.coursier.home|coursier_home|.sbt_home/.coursier"
	"sbt.boot.directory|sbt_boot|.sbt_home/boot"
	"sbt.global.base|sbt_global|.sbt_home"
)

# Default sbt Java system properties set by the buildpack, applied during both build and runtime
readonly sbt_buildpack_default_properties=(
	"sbt.log.noformat=true"
	"sbt.color=false"
)

readonly sbt_launcher_dir_name="sbt-launcher"

# Used by openjdk::install_openjdk_via_jvm_common_buildpack to determine which JVM common buildpack to use
# Configuring this via system.properties is deprecated and will be removed soon
# shellcheck disable=SC2034
JVM_COMMON_BUILDPACK="$(config::get "${BUILD_DIR}" "heroku.jvm.buildpack" "JVM_COMMON_BUILDPACK" "https://buildpack-registry.s3.us-east-1.amazonaws.com/buildpacks/heroku/jvm.tgz")"

SBT_PROJECT="$(config::get "${BUILD_DIR}" "sbt.project" "SBT_PROJECT")"
SBT_PRE_TASKS="$(config::get "${BUILD_DIR}" "sbt.pre-tasks" "SBT_PRE_TASKS")"
SBT_CLEAN="$(config::get "${BUILD_DIR}" "sbt.clean" "SBT_CLEAN" "false")"

# Track usage of configuration options
for env_var in SBT_PRE_TASKS SBT_PROJECT SBT_TASKS KEEP_SBT_CACHE KEEP_COURSIER_CACHE SBT_CLEAN DISABLE_DEPENDENCY_CLASSPATH_LOG; do
	if [[ -n "${!env_var:-}" ]]; then
		metrics::set_string "${env_var,,}" "${!env_var}"
	fi
done

# Install the JDK
openjdk::install_openjdk_via_jvm_common_buildpack "${BUILD_DIR}" "${BUILDPACK_DIR}"

sbt_version="$(java_properties::get "${BUILD_DIR}/project/build.properties" "sbt.version")"
metrics::set_string "sbt_version" "${sbt_version:-"unknown"}"

if [[ -z "${sbt_version}" ]]; then
	output::error <<-EOF
		Error: sbt version cannot be determined.

		As part of your build definition you must specify the version of sbt that
		your build uses. This ensures consistent results across different environments.

		To fix this issue, create a file named project/build.properties that specifies
		the sbt version as follows:

		    sbt.version=1.11.7

		For more information, see:
		https://www.scala-sbt.org/1.x/docs/Basic-Def.html#Specifying+the+sbt+version
	EOF

	exit 1
fi

case "${sbt_version}" in
0.*)
	output::warning <<-EOF
		Warning: Unsupported sbt version detected.

		This buildpack does not officially support sbt ${sbt_version}. You are using
		an end-of-life version that no longer receives security updates or bug fixes.
		Support for sbt 0.x was ended by the upstream sbt project on November 30, 2018.

		Please upgrade to sbt 1.x for active support.

		The buildpack will attempt to build your application, but compatibility
		is not guaranteed and may break at any time.

		For more information:
		- https://web.archive.org/web/20210918065807/https://www.lightbend.com/blog/scala-sbt-127-patchnotes

		Upgrade guide:
		- https://www.scala-sbt.org/1.x/docs/Migrating-from-sbt-013x.html
	EOF
	;;
2.*)
	output::error <<-EOF
		Error: Unsupported sbt version detected.

		This buildpack does not currently support sbt 2.x. You are using sbt ${sbt_version}.

		Support for sbt 2.x will be added in a future buildpack release. In the
		meantime, please use the latest stable sbt 1.x version for your deployments.

		To continue, update project/build.properties to use sbt 1.x.

		For more information:
		- Latest sbt 1.x releases: https://github.com/sbt/sbt/releases
		- sbt 2.x changes: https://www.scala-sbt.org/2.x/docs/en/changes/sbt-2.0-change-summary.html
	EOF

	exit 1
	;;
esac

# Copy the target dir from cache to speed up compilation. This is legacy buildpack
# behavior that other JVM buildpacks don't implement. It can cause cache bloat, stale artifacts,
# and reduced build reproducibility. We've observed customers using SBT_CLEAN (which will remove these files)
# much more than expected (~10% of builds), presumably to work around issues.
# This will be removed in a future version.
target_dir_cache_restore_start_time=$(util::nowms)
util::cache_copy "target" "${CACHE_DIR}" "${BUILD_DIR}"
metrics::set_duration "target_dir_cache_restore_duration" "${target_dir_cache_restore_start_time}"

if [[ -n "${SBT_PROJECT}" ]]; then
	SBT_TASKS="${SBT_PROJECT}/compile ${SBT_PROJECT}/stage"
else
	SBT_TASKS="${SBT_TASKS:-compile stage}"
fi

# To run any tasks before the actual build, configure the environment
# $ heroku config:set SBT_PRE_TASKS=flyway:info
[[ "${SBT_PRE_TASKS}" ]] && SBT_TASKS="${SBT_PRE_TASKS} ${SBT_TASKS}"

# To enable clean compiles, configure the environment to clean:
# $ heroku config:set SBT_CLEAN=true
# $ git push heroku main
# See: https://devcenter.heroku.com/articles/scala-support#clean-builds
[[ "${SBT_CLEAN}" = "true" ]] && SBT_TASKS="clean ${SBT_TASKS}"

for default_property in "${sbt_buildpack_default_properties[@]}"; do
	util::prepend_to_env "SBT_OPTS" "-D${default_property}"
done

# Create sbt directories and configure SBT_OPTS for build time
for directory_property in "${sbt_directory_properties[@]}"; do
	IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
	mkdir -p "${CACHE_DIR}/${cache_path}"
	util::prepend_to_env "SBT_OPTS" "-D${sbt_property}=${CACHE_DIR}/${cache_path}"
done

# Install the Heroku sbt plugin if the exising version differs (or is missing). We do this conditionally to
# ensure we can cache the compiled class files of the plugin between builds, speeding up the build overall.
case "${sbt_version}" in
0.*)
	plugin_source_path="${BUILDPACK_DIR}/opt/sbt-plugin/sbt-0.x/HerokuBuildpackPlugin.scala"
	;;
*)
	plugin_source_path="${BUILDPACK_DIR}/opt/sbt-plugin/sbt-1.x/HerokuBuildpackPlugin.scala"
	;;
esac

plugins_dir="${CACHE_DIR}/sbt_global/plugins"
plugin_destination_path="${plugins_dir}/HerokuBuildpackPlugin.scala"
source_checksum="$(sha256sum "${plugin_source_path}" | awk '{print $1}')"

if [[ ! -f "${plugin_destination_path}" ]] || [[ "${source_checksum}" != "$(sha256sum "${plugin_destination_path}" | awk '{print $1}')" ]]; then
	# We remove the whole directory since we also want to remove the (cached) compiled files
	# for the older version of the plugin in the ./target directory.
	rm -rf "${plugins_dir}"

	mkdir -p "${plugins_dir}"
	cp "${plugin_source_path}" "${plugin_destination_path}"
fi

sbt::install_sbt_launcher "${sbt_version}" "${CACHE_DIR}/sbt-launcher"
export PATH="${CACHE_DIR}/sbt-launcher/bin:${PATH}"

cd "${BUILD_DIR}"
run_sbt "${SBT_TASKS}"

# Gather information about relevant installed sbt plugins
sbt_about_start_time=$(util::nowms)
output::step "Collecting sbt plugin information"
sbt_about_output="$(sbt about 2>&1)"
metrics::set_duration "sbt_about_duration" "${sbt_about_start_time}"

if echo "${sbt_about_output}" | grep -q "com\.typesafe\.sbt\.SbtNativePackager"; then
	app_has_native_packager_sbt_plugin="true"
	metrics::set_raw "uses_sbt_native_packager" "true"
fi

if echo "${sbt_about_output}" | grep -q "play\.sbt\.Play"; then
	metrics::set_raw "is_play_app" "true"
fi

# Collect dependency classpath information for Postgres addon auto-provisioning. This creates a log file containing
# all dependencies and their paths, which is used by bin/release to detect if the app uses Postgres drivers. This
# can be disabled by setting DISABLE_DEPENDENCY_CLASSPATH_LOG if issues occur during dependency resolution.
if [[ -z "${DISABLE_DEPENDENCY_CLASSPATH_LOG:-}" ]]; then
	dependency_classpath_log_start_time=$(util::nowms)
	output::step "Collecting dependency information"
	sbt "show dependencyClasspath" | grep -o "Attributed\(.*\)" >.heroku/sbt-dependency-classpath.log || true
	metrics::set_duration "dependency_classpath_log_duration" "${dependency_classpath_log_start_time}"
fi

# Copy the target dir back to cache for the next build (see cache restore comment above for context)
target_dir_cache_write_start_time=$(util::nowms)
util::cache_copy "target" "${BUILD_DIR}" "${CACHE_DIR}"
metrics::set_duration "target_dir_cache_write_duration" "${target_dir_cache_write_start_time}"

# Write export script for use by subsequent buildpacks. The export script sets up the environment so that other
# buildpacks in the chain can access sbt and its configuration during their build phase. This script is sourced by
# the buildpack framework between buildpack executions.
cat <<-EOF >"${BASE_DIR}/export"
	export PATH="${CACHE_DIR}/${sbt_launcher_dir_name}/bin:\$PATH"

	$(for default_property in "${sbt_buildpack_default_properties[@]}"; do
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${default_property}\""
	done)

	$(for directory_property in "${sbt_directory_properties[@]}"; do
		IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${sbt_property}=${CACHE_DIR}/${cache_path}\""
	done)
EOF

# Historically, the buildpack made sbt and all cached dependencies available at runtime. While we eventually want to
# phase out this feature for parity with other JVM buildpacks, we still support it for backwards compatibility. To
# preserve this feature, we copy all sbt-related directories into the slug and write a profile.d script so that sbt
# will find those directories at runtime. This approach keeps the buildpack source clean and makes it easy to phase
# out this feature in the future.
if [[ "${SBT_AT_RUNTIME:-"true"}" == "true" ]]; then
	sbt_runtime_copy_start_time=$(util::nowms)
	output::step "Copying sbt and dependencies into slug for runtime use"

	# Copy sbt launcher from cache into slug
	if [[ -d "${CACHE_DIR}/${sbt_launcher_dir_name}" ]]; then
		mkdir -p "${BUILD_DIR}/.heroku/scala"
		cp -r "${CACHE_DIR}/${sbt_launcher_dir_name}" "${BUILD_DIR}/.heroku/scala/${sbt_launcher_dir_name}"
	fi

	profile_d_script_path="${BUILD_DIR}/.profile.d/scala.sh"
	mkdir -p "$(dirname "${profile_d_script_path}")"
	cat <<-EOF >"${profile_d_script_path}"
		export PATH="\$HOME/.heroku/scala/${sbt_launcher_dir_name}/bin:\$PATH"
	EOF

	for directory_property in "${sbt_directory_properties[@]}"; do
		IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
		mkdir -p "${BUILD_DIR}/${slug_path}"
		# For historic reasons, some sbt runtime directories are configured to be subdirectories of
		# each other. Using '/.' copies the contents of the source into the destination, preventing
		# 'cp' from creating an additional layer of directories when the destination already exists.
		cp -r "${CACHE_DIR}/${cache_path}/." "${BUILD_DIR}/${slug_path}/"
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${sbt_property}=\$HOME/${slug_path}\"" >>"${profile_d_script_path}"
	done

	for default_property in "${sbt_buildpack_default_properties[@]}"; do
		echo "export SBT_OPTS=\"\${SBT_OPTS:-} -D${default_property}\"" >>"${profile_d_script_path}"
	done

	metrics::set_duration "sbt_runtime_copy_duration" "${sbt_runtime_copy_start_time}"
fi

# When sbt-native-packager is used, a standalone JAR file with all code and dependencies is created. This makes the
# other JAR and class files redundant since they are not used by the running application. We remove these files here
# to reduce the slug size. However, this is a broad assumption that is often but not always correct. Users might want
# to use these files to run the application differently or for other purposes. This is legacy behavior that we will not
# change at this point to avoid users running into slug size limits needlessly. Ideally customers would curate their
# builds to not include extraneous files.
if [[ -n "${app_has_native_packager_sbt_plugin:-}" ]] && [[ "${KEEP_SBT_CACHE:-}" != "true" ]]; then
	artifact_cleanup_start_time=$(util::nowms)
	output::step "Dropping compilation artifacts from the slug"
	rm -rf "${BUILD_DIR}/target/scala-"*
	rm -rf "${BUILD_DIR}/target/streams"
	find "${BUILD_DIR}/target/resolution-cache" -mindepth 1 ! -name "reports" ! -name "*-compile.xml" -exec rm -rf {} + 2>/dev/null || true

	for directory_property in "${sbt_directory_properties[@]}"; do
		IFS='|' read -r sbt_property cache_path slug_path <<<"${directory_property}"
		# sbt's global directory must not be deleted. It does not contain compilation artifacts related to
		# the customers app and is required for sbt operations at runtime.
		if [[ "${sbt_property}" == "sbt.global.base" ]]; then
			continue
		fi

		rm -rf "${BUILD_DIR:?}/${slug_path:?}"/*
	done

	metrics::set_duration "artifact_cleanup_duration" "${artifact_cleanup_start_time}"
fi
